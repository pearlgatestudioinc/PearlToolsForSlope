<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pearl Tools For Slopes</title>
    <link
      rel="icon"
      href="./Icons/Pearl Gate StudioNoSubtext.ico"
      type="image/x-icon"
    />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 5px;
      }

      #container {
        margin-top: 20px;
        width: 200px; /* Ensure consistent width for both containers */
      }
      #Slopes,
      #PositionOverDistance,
      #ElevationPoints,
      #DistanceForPoints {
        display: inline-block; /* Display the containers side by side */
        vertical-align: top; /* Align them to the top */
        margin-right: 20px; /* Add some spacing between the columns */
        width: 200px; /* Ensure consistent width for both containers */
      }

      .textbox-wrapper {
        display: flex; /* Use inline-flex to keep elements in a row */
        align-items: center;
        margin-bottom: 10px; /* Add spacing between rows */
      }

      .textbox-wrapper label {
        width: 15px; /* Fixed width for label */
        margin-right: 10px; /* Ensure consistent spacing between label and textbox */
      }

      #DistanceForPoints .textbox-wrapper label {
        width: 20px; /* Fixed width for label */
        margin-right: 10px; /* Ensure consistent spacing between label and textbox */
      }

      #PositionOverDistance .textbox-wrapper label {
        width: 20px; /* Fixed width for label */
        margin-right: 10px; /* Ensure consistent spacing between label and textbox */
      }
      .textbox-wrapper input {
        width: 60px;
        height: 30px;
      }

      .switch-button {
        background: url("./Icons/btn_refresh_f.png") no-repeat center center;
        background-size: contain;
        border: none;
        width: 40px;
        height: 40px;
        cursor: pointer;
        padding-left: 20px;
      }
      .switch-button:hover {
        opacity: 0.8; /* Add a hover effect for better interactivity */
      }

      .btnDelete {
        background: url("./Icons/btn_colse_f.png") no-repeat center center;
        background-size: contain;
        border: none;
        width: 40px;
        height: 40px;
        cursor: pointer;
      }

      .btnDelete:hover {
        opacity: 0.8; /* Add a hover effect for better interactivity */
      }

      .toggleButton_PointAEdit {
        background: url("./Icons/btn_up_n.png") no-repeat center center;
        background-size: contain;
        border: none;
        width: 40px;
        height: 40px;
        cursor: pointer;
      }

      .toggleButton_PointAEdit:hover {
        opacity: 0.8; /* Add a hover effect for better interactivity */
      }
      .toggleButton_DistanceEdit {
        background: url("./Icons/btn_next_n.png") no-repeat center center;
        background-size: contain;
        border: none;
        width: 40px;
        height: 40px;
        cursor: pointer;
      }
      .toggleButton_DistanceEdit:hover {
        opacity: 0.8; /* Add a hover effect for better interactivity */
      }

      #addButton {
        display: block; /* Make the button appear as a block element */
        margin-bottom: 20px; /* Add spacing below the button */
      }

      @media (max-width: 480px) {
        #ElevationPoints,
        #DistanceForPoints {
          display: inline-block;
          margin-right: 5px; /* Reduce margin for smaller screens */
          width: 48%; /* Slightly reduce width to prevent wrapping */
          vertical-align: top;
        }
      }

      @media (max-width: 480px) {
        #Slopes,
        #PositionOverDistance {
          display: inline-block;
          margin-right: 5px; /* Reduce margin for smaller screens */
          width: 48%; /* Slightly reduce width to prevent wrapping */
          vertical-align: top;
        }
      }

      .toggleButton_PointAEdit.active {
        background: url("./Icons/btn_up_f.png") no-repeat center center;
        background-size: contain;
        border: none;
        width: 40px;
        height: 40px;
        cursor: pointer;
      }

      .toggleButton_DistanceEdit.active {
        background: url("./Icons/btn_next_f.png") no-repeat center center;
        background-size: contain;
        border: none;
        width: 40px;
        height: 40px;
        cursor: pointer;
      }
    </style>
  </head>

  <body>
    <h1>Pearl Gate Studio - Pearl Tools For Slope</h1>
    <button id="addButton">Add Textbox</button>
    <div id="ElevationPoints"><b>ElevationPoints</b></div>
    <div id="DistanceForPoints"><b>DistanceForPoints</b></div>
    <div id="Slopes"><b>Slopes</b></div>
    <div id="PositionOverDistance"><b>Position Over Distance</b></div>

    <script>
      const container = document.getElementById("ElevationPoints");
      const DistanceForPoints = document.getElementById("DistanceForPoints");
      const PositionOverDistance = document.getElementById(
        "PositionOverDistance"
      );
      const slopesContainer = document.getElementById("Slopes");
      const addButton = document.getElementById("addButton");
      let activeSlopeToggleButton = null; // Track the active slope toggle button
      // Global arrays to store references to textboxes
      const elevationPointsTextboxes = [];
      const distanceForPointsTextboxes = [];
      const slopesTextboxes = [];
      const positionOverDistanceTextboxes = [];

      let count = 0; // Start count for textboxes
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // Alphabet for labels

      initialize();

      function initialize() {
        addButton.addEventListener("click", () => {
          if (count === 0) {
            addElevationPointTextbox(); // Create the first textbox
            addElevationPointTextbox(); // Create the second textbox
            createDistanceTextBoxWrapper(); // Create the first distance textbox
            CreateSlopesTextBoxWrapper();
            CreatePositionOverDistanceTextBoxWrapper();
            CalculateSlopes();
          } else {
            addElevationPointTextbox(); // Create one textbox for subsequent clicks
            createDistanceTextBoxWrapper(); // Create one distance textbox for subsequent clicks
            CreateSlopesTextBoxWrapper();
            CreatePositionOverDistanceTextBoxWrapper();
            CalculateSlopes();
          }
        });
      }

      function addElevationPointTextbox() {
        if (count >= alphabet.length) {
          alert("Maximum number of textboxes reached!");
          return;
        }

        const wrapper = document.createElement("div");
        wrapper.className = "textbox-wrapper";

        const label = document.createElement("label");
        label.textContent = `${alphabet[count]}:`;

        const textbox = document.createElement("input");
        textbox.type = "number";
        textbox.value = "0";

        textbox.addEventListener("input", () => {
          CalculateSlopes(); // Recalculate slopes when elevation changes
        });

        wrapper.appendChild(label);
        wrapper.appendChild(textbox);

        // Add switch button
        if (count > 0) {
          addSwitchButton(wrapper, textbox);
        }

        // Add delete button
        if (count > 1) {
          addDeleteButton(wrapper);
        }

        container.appendChild(wrapper);
        elevationPointsTextboxes.push(textbox); // Add to global array
        count++;
      }

      function addSwitchButton(wrapper, textbox) {
        const switchButton = document.createElement("button");
        switchButton.className = "switch-button";
        switchButton.addEventListener("click", () => {
          const previousTextbox = elevationPointsTextboxes[count - 1 - 1]; // Access previous textbox directly
          if (previousTextbox) {
            const tempValue = previousTextbox.value;
            previousTextbox.value = textbox.value;
            textbox.value = tempValue;
          }
        });
        wrapper.appendChild(switchButton);
      }

      function addDeleteButton(wrapper) {
        const deleteButton = document.createElement("button");
        deleteButton.className = "btnDelete";
        deleteButton.addEventListener("click", () => {
          const index = elevationPointsTextboxes.indexOf(
            wrapper.querySelector("input")
          );
          if (index !== -1) {
            elevationPointsTextboxes.splice(index, 1); // Remove from global array
          }

          container.removeChild(wrapper);

          if (count > 2) {
            removeLastDistanceTextbox();
            removeLastSlopeTextbox();
            removeLastPositionOverDistanceTextbox();
          }

          count--;
          updateLabels();
          CalculateSlopes(); // Recalculate slopes after deletion
        });
        wrapper.appendChild(deleteButton);
      }

      function removeLastDistanceTextbox() {
        if (distanceForPointsTextboxes.length > 0) {
          const lastTextbox = distanceForPointsTextboxes.pop(); // Remove from global array
          DistanceForPoints.removeChild(lastTextbox.parentElement);
        }
      }

      function removeLastSlopeTextbox() {
        if (slopesTextboxes.length > 0) {
          const lastTextbox = slopesTextboxes.pop(); // Remove from global array
          slopesContainer.removeChild(lastTextbox.parentElement);
        }
      }

      function removeLastPositionOverDistanceTextbox() {
        if (positionOverDistanceTextboxes.length > 0) {
          const lastTextbox = positionOverDistanceTextboxes.pop(); // Remove from global array
          PositionOverDistance.removeChild(lastTextbox.parentElement);
        }
      }

      function createDistanceTextBoxWrapper() {
        if (count > 1) {
          const wrapper = document.createElement("div");
          wrapper.className = "textbox-wrapper";

          const label = document.createElement("label");
          label.textContent = `${alphabet[count - 2]}${alphabet[count - 1]}:`;

          const textbox = document.createElement("input");
          textbox.type = "number";
          textbox.value = "0";

          wrapper.appendChild(label);
          wrapper.appendChild(textbox);
          DistanceForPoints.appendChild(wrapper);
          distanceForPointsTextboxes.push(textbox); // Add to global array
        }
      }

      function CreateSlopesTextBoxWrapper() {
        if (count > 1) {
          const wrapper = document.createElement("div");
          wrapper.className = "textbox-wrapper";

          const label = document.createElement("label");
          label.textContent = `${alphabet[count - 2]}${alphabet[count - 1]}:`;

          const span = document.createElement("span");
          span.textContent = "0.00%";
          span.style.marginLeft = "10px";

          const textbox = document.createElement("input");
          textbox.type = "number";
          textbox.value = "0";
          textbox.readOnly = true;
          textbox.style.display = "none";

          // Create the slope toggle button
          const toggleButton_PointAEdit = document.createElement("button");
          toggleButton_PointAEdit.className = "toggleButton_PointAEdit";
          toggleButton_PointAEdit.addEventListener("click", () => {
            toggleEditMode(toggleButton_PointAEdit, textbox, span);
          });
          const toggleButton_DistanceEdit = document.createElement("button");
          toggleButton_DistanceEdit.className = "toggleButton_DistanceEdit";
          toggleButton_DistanceEdit.addEventListener("click", () => {
            toggleEditMode(toggleButton_DistanceEdit, textbox, span);
          });
          wrapper.appendChild(label);
          wrapper.appendChild(span);
          wrapper.appendChild(textbox);
          wrapper.appendChild(toggleButton_PointAEdit);
          wrapper.appendChild(toggleButton_DistanceEdit);
          slopesContainer.appendChild(wrapper);
          slopesTextboxes.push(textbox); // Add to global array
        }
      }

      function CreatePositionOverDistanceTextBoxWrapper() {
        if (count > 1) {
          const wrapper = document.createElement("div");
          wrapper.className = "textbox-wrapper";

          const label = document.createElement("label");
          label.textContent = `${alphabet[count - 2]}${alphabet[count - 1]}:`;

          const textbox = document.createElement("input");
          textbox.type = "number";
          textbox.value = "0";
          textbox.style.marginRight = "10px";

          const ofText = document.createElement("span");
          ofText.textContent = "of";

          const distanceValue = document.createElement("i");
          distanceValue.textContent = getDistanceValue(count - 2);
          distanceValue.style.marginLeft = "5px";

          // Update the PositionOverDistance textbox when the corresponding DistanceForPoints value changes
          const correspondingDistanceTextbox =
            distanceForPointsTextboxes[count - 2];
          if (correspondingDistanceTextbox) {
            correspondingDistanceTextbox.addEventListener("input", () => {
              distanceValue.textContent = correspondingDistanceTextbox.value;
              CalculateSlopes(); // Recalculate slopes when distance changes
            });
          }

          wrapper.appendChild(label);
          wrapper.appendChild(textbox);
          wrapper.appendChild(ofText);
          wrapper.appendChild(distanceValue);
          PositionOverDistance.appendChild(wrapper);
          positionOverDistanceTextboxes.push(textbox); // Add to global array
        }
      }

      function updateLabels() {
        // Update labels for ElevationPoints using the global array
        elevationPointsTextboxes.forEach((textbox, index) => {
          const wrapper = textbox.parentElement;
          const label = wrapper.querySelector("label");
          label.textContent = `${alphabet[index]}:`;
        });

        updateDistanceLabels();
      }

      function updateDistanceLabels() {
        // Update labels for DistanceForPoints using the global array
        distanceForPointsTextboxes.forEach((textbox, index) => {
          const wrapper = textbox.parentElement;
          const label = wrapper.querySelector("label");
          label.textContent = `${alphabet[index]}${alphabet[index + 1]}:`;
        });
      }

      function getDistanceValue(index) {
        // Use the global array to get the value directly
        if (index < distanceForPointsTextboxes.length) {
          return distanceForPointsTextboxes[index]?.valueAsNumber || 0;
        }
        return 0;
      }

      function toggleEditMode(toggleButton, textbox, span) {
        if (
          activeSlopeToggleButton == null ||
          activeSlopeToggleButton == toggleButton
        ) {
          const isActive = toggleButton.classList.contains("active");

          if (isActive) {
            // Disable edit mode
            toggleButton.classList.remove("active");
            textbox.style.display = "none";
            textbox.readOnly = true;
            activeSlopeToggleButton = null; // Reset the active button

            // Format the value to 2 decimal places
            const formattedValue = isNaN(parseFloat(textbox.value))
              ? "0.00"
              : parseFloat(textbox.value).toFixed(2);
            span.textContent = `${formattedValue}%`;
            span.style.display = "inline";
          } else {
            // Enable edit mode
            toggleButton.classList.add("active");
            textbox.style.display = "inline";
            textbox.readOnly = false;
            activeSlopeToggleButton = toggleButton; // Set the active button
            span.style.display = "none";
          }
        }
      }

      function DisplaySlope(textbox, decimalValue) {
        const wrapper = textbox.parentElement;
        const span = wrapper.querySelector("span"); // Get the span element

        if (!isNaN(decimalValue)) {
          const percentValue = decimalValue * 100; // Convert to percentage
          const newValue = `${percentValue.toFixed(2)}% (${decimalValue.toFixed(
            2
          )})`;
          if (span) {
            textbox.value = newValue; // Set the textbox value
            span.textContent = newValue; // Update the span text
          }
        } else {
          if (span) {
            textbox.value = "Need More (NM)";
            span.textContent = "Need More (NM)";
          }
        }
      }

      function CalculateSlopes() {
        for (let i = 0; i < slopesTextboxes.length; i++) {
          const elevation1 = parseFloat(elevationPointsTextboxes[i].value);
          const elevation2 = parseFloat(elevationPointsTextboxes[i + 1].value);
          const distance = parseFloat(distanceForPointsTextboxes[i].value);

          if (!isNaN(elevation1) && !isNaN(elevation2) && !isNaN(distance)) {
            const slope = (elevation2 - elevation1) / distance;
            DisplaySlope(slopesTextboxes[i], slope); // Use DisplaySlope for formatting
          } else {
            DisplaySlope(slopesTextboxes[i], NaN); // Handle invalid input
          }
        }
      }
    </script>
  </body>
</html>
